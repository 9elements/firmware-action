---
name: 'Compile open firmware solution'
description: |
  Compile a selected firmware solution like coreboot, EDKII, OpenBMC and more
author: '9elements'
inputs:
  config:
    description: |
      Path to the JSON configuration file.
    required: true
  target:
    description: |
      The firmware recipe to build. Use ID from JSON configuration file.
    required: true
  recursive:
    description: |
      Build target recursively, with all of its dependencies.
    required: false
    default: 'false'
  prune:
    description: |
      Remove Dagger container and its volumes after each module (only in recursive mode).
      Enable this when building complex firmware stack in single job recursively and you are running out of disk space.
    required: false
    default: 'false'
  compile:
    description: |
      Compile the action from source instead of downloading pre-compiled binary from releases.
    required: false
    default: 'false'

  # Options passed over to artifact uploading
  artifact-if-no-files-found:
    description: |
      The desired behavior if no files are found using the provided path.

      Available Options:
        warn: Output a warning but do not fail the action
        error: Fail the action with an error message
        ignore: Do not output any warnings or errors, the action does not fail
    default: 'warn'
  artifact-compression-level:
    description: |
      The level of compression for Zlib to be applied to the artifact archive.
      The value can range from 0 to 9:
      - 0: No compression
      - 1: Best speed
      - 6: Default compression (same as GNU Gzip)
      - 9: Best compression
      Higher levels will result in better compression, but will take longer to complete.
      For large files that are not easily compressed, a value of 0 is recommended for significantly faster uploads.
    default: '6'
  artifact-overwrite:
    description: |
      If true, an artifact with a matching name will be deleted before a new one is uploaded.
      If false, the action will fail if an artifact for the given name already exists.
      Does not fail if the artifact does not exist.
    default: 'false'
  ## We do need this enabled because we are uploading the `./firmware-action` directory
  ##   which would not get uploaded at all with this option set to 'false'
  ##   We might change the behavior in the future if anyone needs it
  ##   (maybe just renaming the directory before upload)
  #artifact-include-hidden-files:
  #  description: |
  #    If true, hidden files will be included in the artifact.
  #    If false, hidden files will be excluded from the artifact.
  #  default: 'false'
  ## Not sure how the action would behave if a empty input would be provided,
  ##   and not sure if I want to just give it some arbitrarily picked default.
  ##   So let's leave it empty and the actions/upload-artifact will just pick the
  ##   repository default.
  #artifact-retention-days:
  #  description: |
  #    Duration after which artifact will expire in days. 0 means using default retention.
  #
  #    Minimum 1 day.
  #    Maximum 90 days unless changed from the repository settings page.

outputs:
  artifact-name:
    description: |
      Name of the artifact which will be uploaded to GitHub
    value: ${{ steps.get_artifact_name.outputs.artifact_name }}

  # These outputs are just passing on outputs of 'upload-artifact'
  #   Docs: https://github.com/actions/upload-artifact
  artifact-id:
    description: |
      GitHub ID of an Artifact, can be used by the REST API
    value: ${{ steps.upload_artifact.outputs.artifact-id }}
  artifact-url:
    description: |
      URL to download an Artifact. Can be used in many scenarios such as linking to artifacts in issues or pull requests. Users must be logged-in in order for this URL to work. This URL is valid as long as the artifact has not expired or the artifact, run or repository have not been deleted
    value: ${{ steps.upload_artifact.outputs.artifact-url }}
  artifact-digest:
    description: |
      SHA-256 digest of an Artifact
    value: ${{ steps.upload_artifact.outputs.artifact-digest }}

runs:
  using: 'composite'
  steps:
    - id: version
      shell: bash
      run: echo "version=v0.14.1" >> "${GITHUB_OUTPUT}"

    - id: arch
      # This ARCH is used to fetch correct executable of firmware-action
      # GoReleaser uses 'x86_64' instead of 'amd64'
      shell: bash
      run: |
        if [ ${{ runner.arch }} = "X64" ]; then
          echo "arch=x86_64" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "amd64" ]; then
          echo "arch=x86_64" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "X86" ]; then
          echo "arch=i386" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "ARM64" ]; then
          echo "arch=arm64" >> "${GITHUB_OUTPUT}"
        else
          echo "arch=${{ runner.arch }}" >> "${GITHUB_OUTPUT}"
        fi

    - id: os
      shell: bash
      run: |
        if [ ${{ runner.os }} = "macOS" ]; then
          echo "os=Darwin" >> "${GITHUB_OUTPUT}"
        else
          echo "os=${{ runner.os }}" >> "${GITHUB_OUTPUT}"
        fi
      # Because MacOS is named Darwin in golang releaser

    - id: ext
      shell: bash
      run: |
        if [ ${{ runner.os }} = "Windows" ]; then
          echo "ext=zip" >> "${GITHUB_OUTPUT}"
        else
          echo "ext=tar.gz" >> "${GITHUB_OUTPUT}"
        fi
      # Both Linux and MacOS use 'tar.gz'

    - id: filename
      shell: bash
      run: |
        echo "filename=firmware-action_${{ steps.os.outputs.os }}_${{ steps.arch.outputs.arch }}.${{ steps.ext.outputs.ext }}" >> "${GITHUB_OUTPUT}"
    - id: url
      shell: bash
      run: |
        echo "url=https://github.com/9elements/firmware-action/releases/download/${{ steps.version.outputs.version }}/${{ steps.filename.outputs.filename }}" >> "${GITHUB_OUTPUT}"

    - name: setup_go
      if: ${{ inputs.compile == 'true' }}
      uses: actions/setup-go@v5
      with:
        go-version: stable

    #==============================================
    # Acquire firmware-action executable for Linux
    #==============================================
    - id: fetch_unix
      if: ${{ ( runner.os == 'Linux' || runner.os == 'macOS' ) && inputs.compile == 'false' }}
      shell: bash
      run: |
        echo "::group::curl"
        curl -L -o "${{ steps.filename.outputs.filename }}" "${{ steps.url.outputs.url }}"
        tar -xvzf "${{ steps.filename.outputs.filename }}"
        chmod +x firmware-action
        echo "::endgroup::"
      # chmod should not be necessary, but just to be safe
    - name: compile_unix
      if: ${{ ( runner.os == 'Linux' || runner.os == 'macOS' ) && inputs.compile == 'true' }}
      shell: bash
      working-directory: ./cmd/firmware-action
      run: |
        echo "::group::compile firmware-action"
        go build -ldflags="-s -w" -o ../../firmware-action
        echo "::endgroup::"

    #================================================
    # Acquire firmware-action executable for Windows
    #================================================

    - id: fetch_windows
      if: ${{ runner.os == 'Windows' && inputs.compile == 'false' }}
      shell: pwsh
      run: |
        echo ##[group]fetch
        Invoke-WebRequest -Uri "${{ steps.url.outputs.url }}" -OutFile "${{ steps.filename.outputs.filename }}"
        Expand-Archive -Path "${{ steps.filename.outputs.filename }}" -DestinationPath .\
        echo ##[endgroup]
    - name: compile_windows
      if: ${{ runner.os == 'Windows' && inputs.compile == 'true' }}
      shell: pwsh
      working-directory: ./cmd/firmware-action
      run: |
        echo ##[group]compile firmware-action
        go build -ldflags="-s -w" -o ../../firmware-action.exe
        echo ##[endgroup]

    #================
    # CACHE: Restore
    #================
    #
    # GitHub does not allow to run a single step in some sort of for-loop, nor does allow to call another
    #   reusable action to potentially use matrix strategy to achieve this.
    # I also looked into GitHub CI commands (link to docs below), but there is no support for uploading
    #   cache or artifacts
    # https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions
    # The only way that I could come up with is to pack it (move all the files into single directory) and then upload.
    #   And upon download it is unpacked.
    # One way might be to implement GitHub API interface right into the golang code, but that seems like too much
    #   overkill for what we want.

    - name: restore_cache
      uses: actions/cache/restore@v4
      id: cache
      with:
        path: .firmware-action/
        key: firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-${{ github.run_id }}
        restore-keys: |
          firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-
          firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-
          firmware-action-${{ inputs.target }}-

    - name: unpack_cached_files
      shell: bash
      if: steps.cache.outputs.cache-hit == 'true'
      run: |
        # Get output directories from config
        mapfile -t OUTPUT_DIRS < <(jq -r '[.. | objects | ."output_dir"? | select(. != null)][]' inputs.config)

        # For each output directory
        for DIR in "${OUTPUT_DIRS[@]}"; do
          if [ -d ".firmware-action/artifacts/${DIR}" ]; then
            mv ".firmware-action/artifacts/${DIR}" ./
          fi
        done

    #=====================
    # ARTIFACTS: Download
    #=====================
    #
    # Download all artifacts for the current workflow run.
    # Docs: https://github.com/actions/download-artifact?tab=readme-ov-file#download-all-artifacts

    - name: download_artifacts
      uses: actions/download-artifact@v4
      with:
        path: .firmware-action2/
        merge-multiple: true
    - name: merge_firmware_action_directory
      shell: bash
      run: |
        # Get output directories from merged config

    #=================================
    # RUN: firmware-action executable
    #=================================

    - name: run_unix
      if: ${{ runner.os == 'Linux' || runner.os == 'macOS' }}
      shell: bash
      run: |
        ./firmware-action
      env:
        INPUT_CONFIG: ${{ inputs.config }}
        INPUT_TARGET: ${{ inputs.target }}
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_PRUNE: ${{ inputs.prune }}

    - name: run_windows
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        .\firmware-action.exe
      env:
        INPUT_CONFIG: ${{ inputs.config }}
        INPUT_TARGET: ${{ inputs.target }}
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_PRUNE: ${{ inputs.prune }}

    #===============
    # CACHE: Create
    #===============

    - name: copy_artifacts
      if: always()
      shell: bash
      run: |
        echo "::group::pack"
        mkdir -p .firmware-action/artifacts/

        # Get output directories from config
        mapfile -t OUTPUT_DIRS < <(jq -r '[.. | objects | ."output_dir"? | select(. != null)][]' "${{ inputs.config }}")

        # For each output directory
        for DIR in "${OUTPUT_DIRS[@]}"; do
          if [ -d "${DIR}" ]; then
            echo "copying ${DIR}"
            cp -r "${DIR}" .firmware-action/artifacts/
          fi
        done

    - name: save_cache
      if: always()
      uses: actions/cache/save@v4
      with:
        path: .firmware-action/
        key: firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-${{ github.run_id }}

    #===================
    # ARTIFACTS: Upload
    #===================

    - name: get_artifact_name
      if: always()
      shell: bash
      id: get_artifact_name
      run: |
        # Extract output_dir for the specific target from config
        OUTPUT_DIR=$(jq -r --arg TARGET "${{ inputs.target }}" 'to_entries[] | select(.value | to_entries[].key == $TARGET) | .value[$TARGET].output_dir' "${{ inputs.config }}" | sed -E 's/\/$//g')
        DATETIME=$(date "+%Y-%m-%d_%H-%M-%S.%N")
        echo "artifact_name=artifacts--${{ inputs.target }}--${OUTPUT_DIR}--${DATETIME}" >> "${GITHUB_OUTPUT}"

    - name: upload_artifact
      if: always()
      uses: actions/upload-artifact@v4
      id: upload_artifact
      with:
        name: ${{ steps.get_artifact_name.outputs.artifact_name }}
        path: .firmware-action/
        include-hidden-files: true
        if-no-files-found: ${{ inputs.artifact-if-no-files-found }}
        compression-level: ${{ inputs.artifact-compression-level }}
        overwrite: ${{ inputs.artifact-overwrite }}
