---
name: 'Compile open firmware solution'
description: |
  Compile a selected firmware solution like coreboot, EDKII, OpenBMC and more
author: '9elements'
inputs:
  config:
    description: |
      Path to the JSON configuration file.
    required: true
  target:
    description: |
      The firmware recipe to build. Use ID from JSON configuration file.
    required: true
  recursive:
    description: |
      Build target recursively, with all of its dependencies.
    required: false
    default: 'false'
  prune:
    description: |
      Remove Dagger container and its volumes after each module (only in recursive mode).
      Enable this when building complex firmware stack in single job recursively and you are running out of disk space.
    required: false
    default: 'false'
  compile:
    description: |
      Compile the action from source instead of downloading pre-compiled binary from releases.
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - id: version
      shell: bash
      run: echo "version=v0.14.1" >> "${GITHUB_OUTPUT}"

    - id: arch
      # This ARCH is used to fetch correct executable of firmware-action
      # GoReleaser uses 'x86_64' instead of 'amd64'
      shell: bash
      run: |
        if [ ${{ runner.arch }} = "X64" ]; then
          echo "arch=x86_64" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "amd64" ]; then
          echo "arch=x86_64" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "X86" ]; then
          echo "arch=i386" >> "${GITHUB_OUTPUT}"
        elif [ ${{ runner.arch }} = "ARM64" ]; then
          echo "arch=arm64" >> "${GITHUB_OUTPUT}"
        else
          echo "arch=${{ runner.arch }}" >> "${GITHUB_OUTPUT}"
        fi

    - id: os
      shell: bash
      run: |
        if [ ${{ runner.os }} = "macOS" ]; then
          echo "os=Darwin" >> "${GITHUB_OUTPUT}"
        else
          echo "os=${{ runner.os }}" >> "${GITHUB_OUTPUT}"
        fi
      # Because MacOS is named Darwin in golang releaser

    - id: ext
      shell: bash
      run: |
        if [ ${{ runner.os }} = "Windows" ]; then
          echo "ext=zip" >> "${GITHUB_OUTPUT}"
        else
          echo "ext=tar.gz" >> "${GITHUB_OUTPUT}"
        fi
      # Both Linux and MacOS use 'tar.gz'

    - id: filename
      shell: bash
      run: |
        echo "filename=firmware-action_${{ steps.os.outputs.os }}_${{ steps.arch.outputs.arch }}.${{ steps.ext.outputs.ext }}" >> "${GITHUB_OUTPUT}"
    - id: url
      shell: bash
      run: |
        echo "url=https://github.com/9elements/firmware-action/releases/download/${{ steps.version.outputs.version }}/${{ steps.filename.outputs.filename }}" >> "${GITHUB_OUTPUT}"

    - name: setup_go
      if: ${{ inputs.compile == 'true' }}
      uses: actions/setup-go@v5
      with:
        go-version: stable

    #==============================================
    # Acquire firmware-action executable for Linux
    #==============================================
    - id: fetch_unix
      if: ${{ ( runner.os == 'Linux' || runner.os == 'macOS' ) && inputs.compile == 'false' }}
      shell: bash
      run: |
        echo "::group::curl"
        curl -L -o "${{ steps.filename.outputs.filename }}" "${{ steps.url.outputs.url }}"
        tar -xvzf "${{ steps.filename.outputs.filename }}"
        chmod +x firmware-action
        echo "::endgroup::"
      # chmod should not be necessary, but just to be safe
    - name: compile_unix
      if: ${{ ( runner.os == 'Linux' || runner.os == 'macOS' ) && inputs.compile == 'true' }}
      shell: bash
      working-directory: ./cmd/firmware-action
      run: |
        echo "::group::compile firmware-action"
        go build -ldflags="-s -w" -o ../../firmware-action
        echo "::endgroup::"

    #================================================
    # Acquire firmware-action executable for Windows
    #================================================

    - id: fetch_windows
      if: ${{ runner.os == 'Windows' && inputs.compile == 'false' }}
      shell: pwsh
      run: |
        echo ##[group]fetch
        Invoke-WebRequest -Uri "${{ steps.url.outputs.url }}" -OutFile "${{ steps.filename.outputs.filename }}"
        Expand-Archive -Path "${{ steps.filename.outputs.filename }}" -DestinationPath .\
        echo ##[endgroup]
    - name: compile_windows
      if: ${{ runner.os == 'Windows' && inputs.compile == 'true' }}
      shell: pwsh
      working-directory: ./cmd/firmware-action
      run: |
        echo ##[group]compile firmware-action
        go build -ldflags="-s -w" -o ../../firmware-action.exe
        echo ##[endgroup]

    #================
    # CACHE: Restore
    #================
    #
    # GitHub does not allow to run a single step in some sort of for-loop, nor does allow to call another
    #   reusable action to potentially use matrix strategy to achieve this.
    # I also looked into GitHub CI commands (link to docs below), but there is no support for uploading
    #   cache or artifacts
    # https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions
    # The only way that I could come up with is to pack it (move all the files into single directory) and then upload.
    #   And upon download it is unpacked.
    # One way might be to implement GitHub API interface right into the golang code, but that seems like too much
    #   overkill for what we want.

    - name: restore_cache
      uses: actions/cache/restore@v4
      id: cache
      with:
        path: .firmware-action/
        key: firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-${{ github.run_id }}
        restore-keys: |
          firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-
          firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-
          firmware-action-${{ inputs.target }}-

    - name: unpack_cached_files
      shell: bash
      if: steps.cache.outputs.cache-hit == 'true'
      run: |
        # Get output directories from config
        mapfile -t OUTPUT_DIRS < <(jq -r '[.. | objects | ."output_dir"? | select(. != null)][]' inputs.config)

        # For each output directory
        for DIR in "${OUTPUT_DIRS[@]}"; do
          if [ -d ".firmware-action/artifacts/${DIR}" ]; then
            mv ".firmware-action/artifacts/${DIR}" ./
          fi
        done

    #=================================
    # RUN: firmware-action executable
    #=================================

    - name: run_unix
      if: ${{ runner.os == 'Linux' || runner.os == 'macOS' }}
      shell: bash
      run: |
        ./firmware-action
      env:
        INPUT_CONFIG: ${{ inputs.config }}
        INPUT_TARGET: ${{ inputs.target }}
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_PRUNE: ${{ inputs.prune }}

    - name: run_windows
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        .\firmware-action.exe
      env:
        INPUT_CONFIG: ${{ inputs.config }}
        INPUT_TARGET: ${{ inputs.target }}
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_PRUNE: ${{ inputs.prune }}

    #===============
    # CACHE: Create
    #===============

    - name: copy_artifacts
      if: always()
      shell: bash
      run: |
        echo "::group::pack"
        mkdir -p .firmware-action/artifacts/

        # Get output directories from config
        mapfile -t OUTPUT_DIRS < <(jq -r '[.. | objects | ."output_dir"? | select(. != null)][]' "${{ inputs.config }}")

        # For each output directory
        for DIR in "${OUTPUT_DIRS[@]}"; do
          if [ -d "${DIR}" ]; then
            echo "copying ${DIR}"
            cp -r "${DIR}" .firmware-action/artifacts/
          fi
        done

    - name: save_cache
      if: always()
      uses: actions/cache/save@v4
      with:
        path: .firmware-action/
        key: firmware-action-${{ inputs.target }}-${{ hashFiles(inputs.config) }}-${{ github.sha }}-${{ github.run_id }}
